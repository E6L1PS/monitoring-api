package ru.ylab.configs;

import org.reflections.Reflections;

/**
 * интерфейс {@code Config} предоставляет методы для получения информации о конфигурации приложения.
 * <p>
 * Классы, реализующие этот интерфейс, должны предоставить информацию о соответствии интерфейсов и их реализаций, а также предоставить доступ к сканеру классов.
 * </p>
 * <p>
 * Для использования создайте класс, реализующий этот интерфейс, и предоставьте логику для получения информации о конфигурации.
 * </p>
 * <p>
 * Метод {@link #getImplClass(Class)} должен возвращать класс реализации для указанного интерфейса.
 * Метод {@link #getScanner()} должен возвращать объект {@link Reflections}, предоставляющий результаты сканирования классов.
 * </p>
 * <p>
 * Обратите внимание, что интерфейс предполагает, что для каждого интерфейса существует ровно одна реализация.
 * </p>
 *
 * @author Pesternikov Danil
 */
public interface Config {

    /**
     * Возвращает класс реализации для указанного интерфейса.
     *
     * @param ifc интерфейс, для которого нужно получить реализацию.
     * @param <T> Тип интерфейса.
     * @return Класс реализации интерфейса.
     * @throws RuntimeException Если количество реализаций интерфейса не равно 1.
     */
    <T> Class<? extends T> getImplClass(Class<T> ifc);

    /**
     * Возвращает объект {@link Reflections}, предоставляющий доступ к результатам сканирования классов.
     *
     * @return Объект Reflections.
     */
    Reflections getScanner();
}
